<?xml version="1.0" encoding="UTF-8"?>
<!--
    /*******************************************************************************
     * Copyright (c) 2011, 2016 Eurotech and/or its affiliates
     *
     * All rights reserved. This program and the accompanying materials
     * are made available under the terms of the Eclipse Public License v1.0
     * which accompanies this distribution, and is available at
     * http://www.eclipse.org/legal/epl-v10.html
     *
     * Contributors:
     *      Eurotech - initial API and implementation
     *******************************************************************************/
 -->

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
		http://camel.apache.org/schema/spring
		http://camel.apache.org/schema/spring/camel-spring-2.15.1.xsd
		http://www.springframework.org/schema/util
        http://www.springframework.org/schema/util/spring-util-3.2.xsd">

<!-- ============================================================== -->
<!--                     TEST CODE                                  -->
<!-- ============================================================== -->

	<!-- LIST OF INSTALLED AMQ FEATURES:
	[installed  ] [2.5.0                ] xml-specs-api                           camel-2.15.1.redhat-621084
	[installed  ] [2.15.1.redhat-621084 ] camel                                   camel-2.15.1.redhat-621084
	[installed  ] [2.15.1.redhat-621084 ] camel-core                              camel-2.15.1.redhat-621084
	[installed  ] [2.15.1.redhat-621084 ] camel-spring                            camel-2.15.1.redhat-621084
	[installed  ] [2.15.1.redhat-621084 ] camel-blueprint                         camel-2.15.1.redhat-621084
	[installed  ] [2.15.1.redhat-621084 ] camel-amqp                              camel-2.15.1.redhat-621084
	[installed  ] [2.15.1.redhat-621084 ] camel-jdbc                              camel-2.15.1.redhat-621084
	[installed  ] [2.15.1.redhat-621084 ] camel-jms                               camel-2.15.1.redhat-621084
	[installed  ] [2.15.1.redhat-621084 ] camel-kafka                             camel-2.15.1.redhat-621084
	[installed  ] [2.15.1.redhat-621084 ] camel-sql                               camel-2.15.1.redhat-621084
	[installed  ] [1.2.0.redhat-621084  ] camel-amq                               fabric-1.2.0.redhat-621084
	 -->
	<!-- ==============================================================
			AMQP CLIENT AND CONNECTION POOL TEST
	 ==============================================================  -->

	<!-- spring connection pool -->
	<!--  
	<bean id="amqp" class="org.apache.camel.component.amqp.AMQPComponent">
		<property name="connectionFactory" ref="cachingConnectionFactory" />
		<property name="cacheLevel" value="2" />
	</bean>
	<bean id="cachingConnectionFactory"
		class="org.springframework.jms.connection.CachingConnectionFactory">
		<property name="targetConnectionFactory" ref="amqRemoteConnectionFactory" />
	</bean>
	<bean id="amqRemoteConnectionFactory" class="org.apache.qpid.client.AMQConnectionFactory">
		<constructor-arg value="amqp://admin:admin@localhost:6000/forwardedTopic?brokerlist='localhost:6000'" />
	</bean>
	-->

	<!-- rough client -->	
	<!-- 
	<bean id="amqp" class="org.apache.camel.component.amqp.AMQPComponent">
       <property name="connectionFactory">
         <bean class="org.apache.qpid.amqp_1_0.jms.impl.ConnectionFactoryImpl" factory-method="createFromURL">
           <constructor-arg index="0" type="java.lang.String" value="amqp://guest:guest@localhost:6000/forwardedTopic" />
         </bean>
       </property>
	</bean>
	 -->
	
	<!-- Pooled connection factory --> 
	<!--
	<bean id="pooledConnectionFactory" class="org.apache.activemq.pool.PooledConnectionFactory"
		init-method="start" destroy-method="stop">
		<property name="maxConnections" value="10" />
		<property name="maximumActiveSessionPerConnection" value="10" />
		<property name="connectionFactory" ref="amqp_connection" />
	</bean>
	-->
	
	<!-- ==============================================================
			!!!AMQP CLIENT AND CONNECTION POOL WORKING!!!
	 ==============================================================  -->
	<!-- WORKING CONNECTION POOLING with A-MQ 6.2.1 (camel 2.15.1-red-hat) to fuse 6.2.1 (camel 2.15.1-red-hat) Dejan will check for amqp version because this one it's the oldest.
	<bean id="myConnectionFactory" class="org.apache.qpid.amqp_1_0.jms.impl.ConnectionFactoryImpl" factory-method="createFromURL">
			<constructor-arg index="0" type="java.lang.String" value="amqp://guest:guest@localhost:6000/forwardedTopic" />
	</bean>
              
	<bean id="cachingConnectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory">
		<property name="targetConnectionFactory" ref="myConnectionFactory"/>
		<property name="sessionCacheSize" value="10" /> it's the maximum number of caches sessions
    </bean>
    <bean id="amqp" class="org.apache.camel.component.amqp.AMQPComponent">
		<property name="connectionFactory" ref="cachingConnectionFactory"/>
		<property name="cacheLevel" value="2"/> 
    </bean>
	 
	<to uri="amqp:queue:forwardedTopic" />
	 
	-->
	
	<!-- ==============================================================
			KAFKA ENDPOINT
	==============================================================  -->
	<!-- 
	from http://camel.apache.org/kafka.html
	
	from("direct:start").process(new Processor() {
		    @Override
		    public void process(Exchange exchange) throws Exception {
		        exchange.getIn().setBody("Test Message from Camel Kafka Component Final",String.class);
		        exchange.getIn().setHeader(KafkaConstants.PARTITION_KEY, 0);
		        exchange.getIn().setHeader(KafkaConstants.KEY, "1");
		    }
		}).to("kafka:localhost:9092?topic=test");
	with spring beans:
	
	<bean ref="processorKafkaHeaderSetter" /> 
	<recipientList>
		<header>kafkaDestination</header>
	</recipientList>
	
	or without processor:
	
	<setHeader headerName="topicCleaned">
		<simple resultType="java.lang.String">${header.JMSDestination.toString().substring(21, ${header.JMSDestination.toString().length()-1})}</simple>
	</setHeader>
	<setHeader headerName="kafkaDestination">
		<simple resultType="java.lang.String">kafka:localhost:9092?serializerClass=kafka.serializer.StringEncoder&amp;topic=${header.topicCleaned}</simple>
	</setHeader>
	<recipientList>
		<header>kafkaDestination</header>
	</recipientList>
	-->
	
	<!-- ==============================================================
            JDBC CONNECTION
     ==============================================================  -->
    <!--
    <bean id="kapuaDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/kapuadb"/>
        <property name="username" value="kapua"/>
        <property name="password" value="Welcome1"/>
    </bean>
    -->

    <!-- ==============================================================
            JDBC CONNECTION POOL
     ==============================================================  -->
    <!--
    <bean id="springDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" >
        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/kapuadb"/>
        <property name="username" value="kapua"/>
        <property name="password" value="Welcome1"/>
        <property name="removeAbandoned" value="true"/>
        <property name="initialSize" value="20" />
        <property name="maxActive" value="30" />
    </bean>
    -->
    
    <!-- ENABLE MULTITHREAD
        add after the from tag
        <threads executorServiceRef="executorServiceManager">
        due to our use case with the concurrentConsumers we have already multithread. We use it only for the endpoint processors 
    -->

	<!-- ==============================================================
			AMQ CONNECTION POOL
	 ==============================================================  -->
	<!-- Configure the ActiveMQ broker connection -->
	<!-- we can use also the tcp regular connection. it should be no performance difference! -->
	<bean id="amqConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory">
		<property name="brokerURL" value="vm://amq?create=false" />
	</bean>

	<bean id="cachingConnectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory">
		<property name="targetConnectionFactory" ref="amqConnectionFactory" />
	</bean>

	<bean id="jmsConfig" class="org.apache.camel.component.jms.JmsConfiguration">
		<property name="connectionFactory" ref="cachingConnectionFactory" />
		<!-- we can remove this setting because is overwritten by the concurrent consumer on jms route -->
		<property name="concurrentConsumers" value="10" />
		<property name="cacheLevelName" value="CACHE_CONSUMER" />
	</bean>

	<bean id="activemq" class="org.apache.activemq.camel.component.ActiveMQComponent">
		<property name="configuration" ref="jmsConfig" />
	</bean>
    <!--  create connection pooling!!! -->
    
	<!-- Converter -->
	<bean id="kapuaConverter" class="org.eclipse.kapua.broker.core.converter.KapuaConverter" />
	
	<!-- Consumer -->
	<!-- ASSISTANTS -->
	<bean id="deviceMessageListener" class="org.eclipse.kapua.broker.core.listener.DeviceMessageListener" >
	</bean>
	<!-- ERROR -->
	<bean id="errorMessageListener" class="org.eclipse.kapua.broker.core.listener.ErrorMessageListener" >
	</bean>
	
	<!-- THREADS POOL FACTORY -->
	<!-- list of start pool name for which the EdcExecutorThreadFactory will replace the ThreadFactory with our implementation -->
	<util:list id="executorThreadFactoryMatcherList" list-class="java.util.ArrayList" value-type="java.lang.String" >
       <value>kapuaExecutorPool</value> <!-- listener for our pojo endpoint -->
       <value>JmsConsumer</value>   <!-- pool used by the camel rout that subscribing amq topics -->
    </util:list>
    <bean id="kapuaExecutorThreadFactory" class="org.eclipse.kapua.broker.core.threadfactory.KapuaExecutorThreadFactory" >
        <constructor-arg index="0" type="java.lang.String" value="KapuaxecutorThreadFactory" />
        <constructor-arg index="1" type="java.util.List" ref="executorThreadFactoryMatcherList" />
        <constructor-arg index="2" type="boolean" value="true" /> <!-- is rootThreadGroup -->
    </bean>
    <bean id="kapuaExecutorThreadPoolFactory" class="org.eclipse.kapua.broker.core.threadfactory.KapuaExecutorThreadPoolFactory" >
        <constructor-arg index="0" type="org.eclipse.kapua.broker.core.threadfactory.KapuaExecutorThreadFactory" ref="kapuaExecutorThreadFactory" />
    </bean>
    
	<camelContext id="camelContext" xmlns="http://camel.apache.org/schema/spring" >
	    <!-- the beans are defined as spring bean so check if it's possible to remove the package scan at all. Remove also the endpoint annotation from the pojo endpoints and all should works. Otherwise send to Dejan a simplified example -->
		<packageScan>
		  <package>com.eurotech.cloud</package>
		  <excludes>**.*Excluded*</excludes>
		  <includes>**.*</includes>
		</packageScan>
        <!-- exception/error handler -->
        	<!-- 
        	by default the errorHandler forward the message to a dead letter queue but in that way we lose the failure end point
        	deadLetterUri="activemq:queue:processedMessageWithError" 
        	if we forward the message directly to an end point with the exchange in the signature
        	deadLetterUri="bean:errorMessagePojo?method=processMessage"
        	we have these properties evaluated (in the exchange field)
        	CamelFailureRouteId
        	CamelFailureEndpoint
        	CamelExceptionCaught
        	(others useful fields CamelMulticastIndex - CamelMessageHistory - CamelCreatedTimestamp)
        	-->
        <errorHandler id="lifeCycleMessageErrorHandler" 
            type="DeadLetterChannel"
            deadLetterUri="bean:errorMessageListener?method=processLifeCycleMessage"
            useOriginalMessage="true">
            <redeliveryPolicy maximumRedeliveries="1" />
        </errorHandler>
        <errorHandler id="serviceMessageErrorHandler" 
            type="DeadLetterChannel"
            deadLetterUri="bean:errorMessageListener?method=processServiceMessage"
            useOriginalMessage="true">
            <redeliveryPolicy maximumRedeliveries="1" />
        </errorHandler>
        
		<!-- Executor thread pool 
		Please check the EdcExecutorThreadPoolFactory comments before modify the threadName attributes
		-->
        <threadPool id="serviceThreads"
                threadName="kapuaExecutorPoolServiceProcessor"
                poolSize="3"
                maxPoolSize="5"
                maxQueueSize="2" />
        <!-- 
        WARNING!!!
        check the JmsConstants.VT_EDCADMIN_CLIENTID_PREFIX used by the EdcInactiveSecurityPlugin before changing the consumer name in the subscriprtions 
        
        ===
        For the transaction/acknowledge mode please follow http://stackoverflow.com/questions/13498652/camel-jms-client-acknowledge-mode
        
        OK. After some some debugging and scanning throug source code I've found out that Camel uses spring MessageListenerContainers.
        The AbstractMessageListenerContainer, in case of CLIENT_AKNOWLEDGE mode, invokes comitIfNecessary method acknowledging message.
        This happens only AFTER registered MessageListener processes message succesfully (no exceptions)
        
        Camel uses EndpointMessageListener which, eventually, invokes process method of next processor (or Producer) down the route.
        As this is classic chain of responsibilities, if any processor down the route throws exception or sets exception on the Exchange,
        it will be re-thrown by EndpointMessageListener preventing the AbstractMessageListener to acknowledge message.
        
        So the camel-jms connections CONFIGURATION TESTED are:
        acknowledgementModeName=CLIENT_ACKNOWLEDGE
        transacted=false
        
        BEFORE CHANGING THESE parameters please run stress test (to check the cpu load) and the qa tests EdcCamelRouteIT (to check the messages persistence)
        -->
		<route id="lifeCycleRoute" errorHandlerRef="lifeCycleMessageErrorHandler" >
			<from uri="activemq:queue:Consumer.eurotech:systemlisteners:EXACTLY_ONCE.VirtualTopic.$EDC.>?asyncConsumer=false&amp;acknowledgementModeName=CLIENT_ACKNOWLEDGE&amp;transacted=false&amp;concurrentConsumers=10&amp;maxConcurrentConsumers=20" />
            <bean ref="kapuaConverter" method="convertTo"/>
			<choice id="lifeCycleBirthChoice">
	            <!-- application birth $EDC/+/+/MQTT/BA/BIRTH -->
	            <when id="lifeCycleBirthFilter">
	            	<simple>${header.JMSDestination} regex '^topic://VirtualTopic\.\$EDC\.(.*\.){2}MQTT\..*'</simple>
	                <multicast>
		                <to uri="bean:deviceMessageListener?method=processMessage" />
	                </multicast>
	            </when>
	            <otherwise>
	  				<to uri="bean:errorMessageListener?method=processUnmatchedMessage" />
		  		</otherwise>
	       </choice>
	   </route>
        <!-- service endpoint -->
		<route id="serviceRoute" errorHandlerRef="serviceMessageErrorHandler" >
		    <!-- check kapua-config file beofre changes this queue name (see amq.broker.queue.service.name) -->
		    <from uri="activemq:queue:EdcService" />
		    <multicast executorServiceRef="serviceThreads" >
                <pipeline>
                    <bean ref="kapuaConverter" method="convertTo"/>
		            <to uri="bean:serviceMessageListener?method=processMessage" />
		        </pipeline>
		    </multicast>
		</route>
	</camelContext>
</beans>